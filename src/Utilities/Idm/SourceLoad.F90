!> @brief This module contains the SourceLoadModule
!!
!! This module contains the routines needed to generate
!! a loader object for an input source and routines
!! that distribute processing to a particular source.
!!
!<
module SourceLoadModule

  use KindModule, only: DP, I4B, LGP
  use SimVariablesModule, only: errmsg
  use ConstantsModule, only: LINELENGTH, LENMEMPATH, LENMODELNAME, LENFTYPE, &
                             LENPACKAGETYPE, LENPACKAGENAME
  use SimModule, only: store_error, store_error_filename
  use ModflowInputModule, only: ModflowInputType, getModflowInput

  implicit none
  private
  public :: create_input_loader
  public :: open_source_file
  public :: load_modelnam, load_simnam, load_simtdis
  public :: remote_model_ndim
  public :: create_context

contains

  !> @brief factory function to create and setup model package static loader
  !<
  function create_input_loader(component_type, subcomponent_type, &
                               component_name, subcomponent_name, input_type, &
                               input_fname, component_fname) result(loader)
    use SourceCommonModule, only: package_source_type, idm_subcomponent_name
    use InputLoadTypeModule, only: StaticPkgLoadBaseType
    character(len=*), intent(in) :: component_type
    character(len=*), intent(in) :: subcomponent_type
    character(len=*), intent(in) :: component_name
    character(len=*), intent(in) :: subcomponent_name
    character(len=*), intent(in) :: input_type
    character(len=*), intent(in) :: input_fname
    character(len=*), intent(in) :: component_fname
    class(StaticPkgLoadBaseType), pointer :: loader
    type(ModflowInputType) :: mf6_input
    character(len=LENPACKAGENAME) :: source_type
    character(len=LENPACKAGENAME) :: sc_name
    !
    ! -- set subcomponent name
    sc_name = idm_subcomponent_name(component_type, subcomponent_type, &
                                    subcomponent_name)
    !
    ! -- create description of input
    mf6_input = getModflowInput(input_type, component_type, subcomponent_type, &
                                component_name, sc_name, input_fname)
    !
    ! -- set package source
    source_type = package_source_type(input_fname)
    !
    ! -- set source loader for model package
    loader => package_loader(source_type, component_fname)
    !
    ! -- initialize loader
    call loader%init(mf6_input, component_name, component_fname, input_fname)
    !
    ! -- return
    return
  end function create_input_loader

  !> @brief allocate source model package static loader
  !<
  function package_loader(source_type, modelfname) result(loader)
    use InputLoadTypeModule, only: StaticPkgLoadBaseType
    use IdmMf6FileModule, only: Mf6FileStaticPkgLoadType
#if defined(__WITH_NETCDF__)
    use IdmNCFileModule, only: NCStaticPkgLoadType
#endif
    character(len=*), intent(inout) :: source_type
    character(len=*), intent(in) :: modelfname
    class(Mf6FileStaticPkgLoadType), pointer :: mf6file_loader
#if defined(__WITH_NETCDF__)
    class(NCStaticPkgLoadType), pointer :: nc_loader
#endif
    class(StaticPkgLoadBaseType), pointer :: loader
    !
    ! -- initialize
    nullify (loader)
    !
    ! -- allocate derived object
    select case (source_type)
    case ('MF6FILE')
      allocate (mf6file_loader)
      loader => mf6file_loader
    case ('NETCDF4')
#if defined(__WITH_NETCDF__)
      allocate (nc_loader)
      loader => nc_loader
#else
      write (errmsg, '(a)') &
        'Cannot load package inputs. NetCDF4 input file provided &
        &but NetCDF4 libraries not available.'
      call store_error(errmsg)
      call store_error_filename(modelfname)
#endif
    case default
      write (errmsg, '(a)') &
        'Simulation package input source type "'//trim(source_type)// &
        '" not currently supported.'
      call store_error(errmsg)
      call store_error_filename(modelfname)
    end select
    !
    ! -- return
    return
  end function package_loader

  function open_source_file(pkgtype, filename, modelfname, iout) result(fd)
    use SourceCommonModule, only: package_source_type
    use IdmMf6FileModule, only: open_mf6file
    character(len=*), intent(in) :: pkgtype
    character(len=*), intent(in) :: filename
    character(len=*), intent(in) :: modelfname
    integer(I4B), intent(in) :: iout
    integer(I4B) :: fd
    character(len=LENPACKAGENAME) :: source_type
    !
    ! -- initialize
    fd = 0
    !
    ! -- set source type
    source_type = package_source_type(filename)
    !
    select case (source_type)
    case ('MF6FILE')
      fd = open_mf6file(pkgtype, filename, modelfname, iout)
    case ('NETCDF4')
#if defined(__WITH_NETCDF__)
      ! -- no-op, don't provide ncid fd to a package
#else
      write (errmsg, '(a)') &
        'Cannot open source input file. NetCDF4 input file provided &
        &but NetCDF4 libraries not available.'
      call store_error(errmsg)
      call store_error_filename(modelfname)
#endif
    case default
    end select
    !
    ! -- return
    return
  end function open_source_file

  subroutine load_modelnam(mtype, mfname, mname, iout)
    use SimVariablesModule, only: simfile
    use SourceCommonModule, only: package_source_type, idm_component_type
    use IdmMf6FileModule, only: input_load
    character(len=*), intent(in) :: mtype
    character(len=*), intent(in) :: mfname
    character(len=*), intent(in) :: mname
    integer(I4B), intent(in) :: iout
    type(ModflowInputType) :: mf6_input
    character(len=LENPACKAGENAME) :: source_type
    !
    ! -- set source type
    source_type = package_source_type(mfname)
    !
    ! -- create description of input
    mf6_input = getModflowInput(mtype, idm_component_type(mtype), &
                                'NAM', mname, 'NAM')
    !
    select case (source_type)
    case ('MF6FILE')
      call input_load(mfname, mf6_input, simfile, iout)
    case ('NETCDF4')
#if defined(__WITH_NETCDF__)
      write (errmsg, '(a)') &
        'NetCDF4 Model name files not currently supported.'
      call store_error(errmsg)
      call store_error_filename(simfile)
#else
      write (errmsg, '(a)') &
        'Cannot load name file. NetCDF4 input file provided &
        &but but NetCDF4 libraries not available.'
      call store_error(errmsg)
      call store_error_filename(simfile)
#endif
    case default
    end select
    !
    ! -- return
    return
  end subroutine load_modelnam

  subroutine load_simnam()
    use SimVariablesModule, only: simfile, iout
    use MessageModule, only: write_message
    use IdmMf6FileModule, only: input_load
    type(ModflowInputType) :: mf6_input
    character(len=LINELENGTH) :: line
    logical :: lexist
    !
    ! -- load mfsim.nam if it exists
    inquire (file=trim(adjustl(simfile)), exist=lexist)
    !
    if (lexist) then
      !
      ! -- write name of namfile to stdout
      write (line, '(2(1x,a))') 'Using Simulation name file:', &
        trim(adjustl(simfile))
      call write_message(line, skipafter=1)
      !
      ! -- create description of input
      mf6_input = getModflowInput('NAM6', 'SIM', 'NAM', 'SIM', 'NAM', simfile)
      !
      ! -- open namfile and load to input context
      call input_load(simfile, mf6_input, simfile, iout)
    end if
    !
    ! -- return
    return
  end subroutine load_simnam

  subroutine load_simtdis()
    ! -- modules
    use SimVariablesModule, only: simfile, iout
    use MemoryHelperModule, only: create_mem_path
    use MemoryManagerModule, only: mem_setptr
    use SimVariablesModule, only: idm_context
    use SourceCommonModule, only: package_source_type
    use IdmMf6FileModule, only: input_load
    ! -- dummy
    ! -- locals
    character(len=LENMEMPATH) :: input_mempath
    type(ModflowInputType) :: mf6_input
    character(len=LENPACKAGENAME) :: source_type
    character(len=:), pointer :: tdis6
    logical :: lexist
    !
    ! -- set input memory path
    input_mempath = create_mem_path('SIM', 'NAM', idm_context)
    !
    ! -- set pointers to input context timing params
    call mem_setptr(tdis6, 'TDIS6', input_mempath)
    !
    ! -- create timing
    if (tdis6 /= '') then
      !
      ! -- set source type
      source_type = package_source_type(tdis6)
      !
      select case (source_type)
      case ('MF6FILE')
        !
        inquire (file=trim(adjustl(tdis6)), exist=lexist)
        !
        if (lexist) then
          !
          ! -- create description of input
          mf6_input = getModflowInput('TDIS6', 'SIM', 'TDIS', &
                                      'SIM', 'TDIS', simfile)
          !
          ! -- open namfile and load to input context
          call input_load(tdis6, mf6_input, simfile, iout)
          !
        else
          write (errmsg, '(a)') &
            'Simulation TIMING input file "'//trim(tdis6)// &
            '" does not exist.'
          call store_error(errmsg)
          call store_error_filename(simfile)
        end if
      case default
      end select
    end if
    !
    ! -- return
    return
  end subroutine load_simtdis

  function remote_model_ndim(mtype, mfname) result(ncelldim)
    use SourceCommonModule, only: package_source_type
    use ConstantsModule, only: LINELENGTH
    use InputOutputModule, only: openfile, getunit
    use BlockParserModule, only: BlockParserType
    character(len=*), intent(in) :: mtype
    character(len=*), intent(in) :: mfname
    integer(I4B) :: ncelldim
    character(len=LENPACKAGENAME) :: source_type
    type(BlockParserType) :: parser
    integer(I4B) :: ierr, inunit
    logical(LGP) :: isfound, endOfBlock
    character(len=LINELENGTH) :: ptype
    !
    ! -- initialize
    ncelldim = 0
    !
    ! -- set source type
    source_type = package_source_type(mfname)
    !
    select case (source_type)
    case ('MF6FILE')
      !
      ! -- open name file
      inunit = getunit()
      call openfile(inunit, 0, trim(adjustl(mfname)), mtype, &
                    'FORMATTED', 'SEQUENTIAL', 'OLD')
      !
      ! -- initialize parser
      call parser%Initialize(inunit, 0)
      !
      ! -- get options block
      call parser%GetBlock('OPTIONS', isfound, ierr, &
                           supportOpenClose=.true., blockRequired=.false.)
      ! -- iterate through options
      if (isfound) then
        do
          call parser%GetNextLine(endOfBlock)
          if (endOfBlock) exit
        end do
      end if
      !
      ! -- get packages block
      call parser%GetBlock('PACKAGES', isfound, ierr, &
                           supportOpenClose=.true., blockRequired=.true.)
      if (isfound) then
        ! -- read through packages
        do
          call parser%GetNextLine(endOfBlock)
          if (endOfBlock) exit
          !
          call parser%GetStringCaps(ptype)
          !
          select case (ptype)
          case ('DIS6')
            ncelldim = 3
            exit
          case ('DISV6')
            ncelldim = 2
            exit
          case ('DISU6')
            ncelldim = 1
            exit
          case default
            write (errmsg, '(a)') &
              'Unknown discretization type "'//trim(ptype)// &
              '" not currently supported.'
            call store_error(errmsg, .true.)
          end select
        end do
      end if
      !
      call parser%clear()
      !
    case default
    end select
    !
    ! -- return
    return
  end function remote_model_ndim

  !> @brief create model context
  !<
  subroutine create_context(modeltype, component_type, modelname, &
                            modelfname, pkglist, iout)
    ! -- modules
    use ModelPackageInputsModule, only: LoadablePackageType
    ! -- drummy
    character(len=*), intent(in) :: modeltype
    character(len=*), intent(in) :: component_type
    character(len=*), intent(in) :: modelname
    character(len=*), intent(in) :: modelfname
    type(LoadablePackageType), dimension(:), &
      allocatable, intent(in) :: pkglist
    integer(I4B), intent(in) :: iout
    ! -- local
    !
    ! -- create netcdf4 context
    call create_nc_context(modeltype, component_type, modelname, &
                           modelfname, pkglist, iout)
    !
    ! -- return
    return
  end subroutine create_context

  !> @brief create model netcdf4 context
  !<
  subroutine create_nc_context(modeltype, component_type, modelname, &
                               modelfname, pkglist, iout)
    use ModelPackageInputsModule, only: LoadablePackageType
    use NCModelInputsModule, only: NCModelInputsType
    use InputModelContextModule, only: AddModelNCContext
#if defined(__WITH_NETCDF__)
    use NCContextBuildModule, only: create_ncpkg_context
    use IdmNCFileModule, only: open_ncfile
    use netcdf
#endif
    ! -- drummy
    character(len=*), intent(in) :: modeltype
    character(len=*), intent(in) :: component_type
    character(len=*), intent(in) :: modelname
    character(len=*), intent(in) :: modelfname
    type(LoadablePackageType), dimension(:), &
      allocatable, intent(in) :: pkglist
    integer(I4B), intent(in) :: iout
    ! -- local
    character(len=LINELENGTH) :: nc_fname
    type(NCModelInputsType), pointer :: nc_context
#if defined(__WITH_NETCDF__)
    integer(I4B) :: ncid
#endif
    !
    ! -- allocate context object
    allocate (nc_context)
    !
    ! -- set model nc filename if provided
    nc_fname = nc_filename(pkglist, modelfname)
    !
    if (nc_fname /= '') then
#if defined(__WITH_NETCDF__)
      !
      call nf_set_log_level(3)
      write(iout, '(a)') 'IDM create_nc_context'
      !
      ! -- open nc input file
      ncid = open_ncfile(nc_fname, iout)
      !ncid = 0
      !
      ! -- init model context object
      call nc_context%init(modeltype, component_type, modelname, nc_fname, ncid)
      !
      ! -- add NETCDF4 packages to context
      call set_nc_pkglist(component_type, modelfname, pkglist, &
                          nc_context, nc_fname)
      !
      ! -- read the file and build the context
      call create_ncpkg_context(nc_context, iout)
      !
#else
      write (errmsg, '(a)') &
        'Cannot load model packages. NetCDF4 input file &
        &specified in model namefile options block but &
        &NetCDF4 libraries are not available.'
      call store_error(errmsg)
      call store_error_filename(modelfname)
#endif
    else
      !
      ! -- initialize object
      call nc_context%init(modeltype, component_type, modelname, '', 0)
      !
    end if
    !
    ! -- add context to model context list
    call AddModelNCContext(modelname, modelfname, nc_context)
    !
    ! -- return
    return
  end subroutine create_nc_context

#if defined(__WITH_NETCDF__)
  subroutine set_nc_pkglist(component_type, modelfname, pkglist, &
                            nc_context, nc_fname)
    use SourceCommonModule, only: package_source_type
    use IdmDfnSelectorModule, only: idm_integrated
    use ModelPackageInputsModule, only: LoadablePackageType
    use NCModelInputsModule, only: NCModelInputsType
    ! -- drummy
    character(len=*), intent(in) :: component_type
    character(len=*), intent(in) :: modelfname
    type(LoadablePackageType), dimension(:), &
      allocatable, intent(in) :: pkglist
    type(NCModelInputsType), pointer, &
      intent(inout) :: nc_context
    character(len=*) :: nc_fname
    ! -- local
    integer(I4B) :: m, n
    !
    ! -- add NETCDF4 packages to context list
    do n = 1, size(pkglist)
      ! -- load package instances
      do m = 1, pkglist(n)%pnum
        !
        if (package_source_type(pkglist(n)%filenames(m)) == 'NETCDF4') then
          !
          if (idm_integrated(component_type, pkglist(n)%subcomponent_type)) then
            !
            ! -- add pkg instance to context object
            call nc_context%add(pkglist(n)%pkgtype, &
                                pkglist(n)%subcomponent_type, &
                                pkglist(n)%pkgnames(m))
            !
          else
            errmsg = 'NetCDF4 is unsupported for package type "'// &
                     trim(pkglist(n)%pkgtype)//'".'
            call store_error(errmsg)
            call store_error_filename(modelfname)
          end if
        end if
      end do
    end do
    !
    ! -- return
    return
  end subroutine set_nc_pkglist
#endif

  !> @brief set model netcdf4 input filename
  !<
  function nc_filename(pkglist, modelfname) result(nc_fname)
    use ModelPackageInputsModule, only: LoadablePackageType
    use SourceCommonModule, only: package_source_type
    ! -- drummy
    type(LoadablePackageType), dimension(:), &
      allocatable, intent(in) :: pkglist
    character(len=*), intent(in) :: modelfname
    ! -- local
    character(len=LINELENGTH) :: nc_fname
    integer(I4B) :: m, n
    !
    ! -- initialize
    nc_fname = ''
    !
    ! -- verify single model nc file
    do n = 1, size(pkglist)
      do m = 1, pkglist(n)%pnum
        if (package_source_type(pkglist(n)%filenames(m)) == 'NETCDF4') then
          if (nc_fname == '') then
            nc_fname = pkglist(n)%filenames(m)
          else if (nc_fname /= pkglist(n)%filenames(m)) then
            nc_fname = ''
            errmsg = 'Multiple *.nc model input files detected in packages &
                     &block. Only one model NetCDF4 input supported.'
            call store_error(errmsg)
            call store_error_filename(modelfname)
          end if
        end if
      end do
    end do
    !
    ! -- return
    return
  end function nc_filename

end module SourceLoadModule
